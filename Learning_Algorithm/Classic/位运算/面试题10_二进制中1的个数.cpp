/*
	面试题10：二进制中1的个数

	题目：请实现一个函数，输入一个整数，输出该数二进制表示中1的个数。
		  例如把9表示成二进制是1001，有两位是1。因此如果输入9，该数输出2。
*/


/*
 * #1 可能引起死循环的解法――右移
 * 思路：首先判断整数二进制表示中的最右边一位是不是１；然后把输入的整数右移一位；
 *       重复，直到整数变为０为止。
 * 导致死循环的原因：假如输入一个“负数”，比如0x80000000，那么把负数右移一位时，
 *                 并不是简单的把最高位的１移到第二位变成0x40000000，而是0x00000000。
 　　　　　　　　　　这是因为移位前是负数，那么移位后仍保证整数位负数，因为最高位会设为１。
 *                 如果一直做移位运算，最终这个整数会变成0xFFFFFFFF而陷入死循环。
 */
int getNumberOf1_bad(int n)
{
	int count = 0;
	while (n)
	{
		if (n & 1)// n & 1 == 1 => 数字ｎ二进制的最右边一位为１
			++count;
		n = n >> 1;//　数字ｎ右移一位（效率比除以２高的多）<=>十进制数ｎ除以２
	}
	return count;
}

/*
 * #2 常规解法――左移的次数等于二进制的位数
 * 思路：在#1解法中，引起死循环主要因为每次需要把整数二进制表示右移。
 * 　　　这里我们不在右移输入的数字ｎ，而是首先把数字ｎ和１做位与运算，判断ｎ的最低位是不是１.
 *	　　 接着把１左移一位得到２，再和数字ｎ做位与运算，以此判断ｎ的次低位是不是１；重复即可。
 *
 * 时间复杂度：该解法左移的次数等于输入整数二进制的位数，32位的整数需要循环32次。
 */
int getNumberOf1_better(int n)
{
	int count = 0;
	unsigned int flag = 1;
	while (flag) {
		if (n&flag) {// ！！！从右到左依次判断每一位是否为１
			++count;
		}
		// 更新flag
		flag = flag << 1;//等价于乘以２！ 1=>00000001，1<<1=>2:00000010 ...
	}
	return count;
}

 /*
  * #3 带来惊喜的解法――左移的次数等于二进制中１的个数
  * 思路：(n - 1) & n表示把ｎ的二进制表示中最右边的１变为0
  *
  * 时间复杂度：该解法左移的次数等于输入整数二进制表示中１的个数。
  */
int getNumberOf1_best(int n)
{
	int count = 0;
	while (n) {
		++count;
		n = (n - 1)&n;// (n - 1)&n把ｎ的二进制表示中最右边的１变为０；再赋值给n，重复循环
	}
	return count;
}